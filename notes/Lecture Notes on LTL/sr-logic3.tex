\section{Temporal Logic}

Predicate logic is a powerful logic, but not decidable in
general.\footnote{Knowledge of predicate logic is not required for
  these notes. But because of its importance in general and for a
  deeper understanding of model checking, we recall the basic
  definitions in an appendix.}  In this section, we will look at
special kinds of models and logics that have a certain form of
quantification but are still decidable. The general idea is, on the
one hand, to look at special models (transition systems, execution
sequences) and on the other hand, to only allow restricted use of
quantification (eg always, sometimes).


%\input{sr-logic-ltl}%LTL
\subsection{(Linear) Temporal Logic}\label{sec:LTL:def}

Linear temporal logic (LTL) is interpreted over infinite sequences,
also called runs or execution sequences. `Linear' emphasises that the
logic speaks about sequences and not, for example, about trees. The
semantics of LTL wrt sequences can be extended to a semantics wrt
transition systems by considering all execution sequences generated by
the transition system.

%%%%%\subsubsection{Definition of LTL}\label{sec:LTL:def}

\bigskip\noindent\textbf{Syntax of LTL\@. } $\Fma::=p \mid \neg\Fma \mid
\Fma\et\Fma \mid \next \Fma \mid \Box\Fma \mid \Diamond\Fma \mid
\Fma\until\Fma$
 
\medskip\noindent\textit{Precedence rules. } To save brackets, we say
that the unary operators bind stronger than $\until$ which binds
stronger than $\et,\ou$ which bind stronger than $\imp$ which binds
stronger than $\biimp$. For example, \[\neg p\et \Diamond q\until \Box
r \et s \imp t \biimp u\]
is bracketed as \[((\neg p\et ((\Diamond
q)\until \Box r) \et s) \imp t) \biimp u\]

\bigskip\noindent\textbf{Semantics of LTL\@. } Let $M=(v_n)_{n\in\bbN}$
be a sequence\footnote{$\bbN=\{0,1,2\ldots\}$ denotes the set of
  natural numbers; $(v_n)_{n\in\bbN}$, or $(v_n)$, is short
  for $(v_0,v_1,v_2\ldots)$.} of valuations $v_n:\bbP\to\bbtwo$.
\begin{itemize}
\item $M,n\models p$ \ if $v_n(p)=1$,
\item $M,n\models \neg \phi$ \ if not $M,n\models\phi$,
\item $M,n\models \phi\et\psi$ \ if $M,n\models\phi$ and
  $M,n\models\psi$,
\item $M,n\models\next\phi$ \ if $M,n+1\models\phi$,
\item $M,n\models\Box\phi$ \ if $M,m\models\phi$ for all $m\ge n$,
\item $M,n\models\Diamond\phi$ \ if $M,m\models\phi$ for some $m\ge n$,
\item $M,n\models \phi\until\psi$ \ if \ \
  \parbox{15em}{$M,m\models\psi$ for some $m> n$ and\\
    $M,k\models\phi$ for all $k$ with $n< k < m$.}
\end{itemize}

\noindent $M\models\phi$ \ if $M,n\models\phi$ for all $n\in\bbN$.\\
$M\models\Phi$ and $\Phi\models\phi$ and $\models\phi$ (`$\phi$ is
valid') as before.

\bigskip\noindent\textbf{Terminology. } Read \\
\renewcommand{\arraystretch}{1.4}
\hspace*{2em} \begin{tabular}{rcl}
$\next\phi$ && next $\phi$, \\
$\Box \phi$ & & always $\phi$,\\
$\Diamond\phi$ && sometimes $\phi$, or eventually $\phi$,\\ 
$\phi\until\psi$ && $\phi$ until $\psi$.
\end{tabular}

\bigskip\noindent\textbf{Remark. }
% \begin{enumerate}
% \item
[Only for readers of Appendix~\ref{sec:ml}] A model for LTL is a model
for ML where we take $\bbN$ as the carrier set and two relations. The
first relation is $\{(n,n+1)\mid n\in\bbN\}$ and interprets the
$\next$.\footnote{The box and the diamond for this relation are the
  same as each state $n$ has a unique successor; we therefore only
  need one operator and write it as $\next$.} The second relation is
$\le$ and interprets $\Box$ and $\Diamond$.
%\end{enumerate}

\bigskip\noindent\textbf{Some important formulae. }
%
\begin{center}
\begin{tabular}{|l|l|}
  \hline
  $\Box\Diamond p$ & infinitely often $p$\\
  \hline
  $\Diamond\Box p$ & eventually $p$ will always be true\\
  \hline
  $\neg (\neg p \until q)$ & p before q (see below) \\ 
  \hline
  $\Box(p\imp\Diamond q)$ &  progress: each `request' p gets `acknowledgement' q\\
  \hline
  $\neg\Diamond\Box p$ &  weak fairness: not forever `blocked at p'\\
  \hline
  $\Box\Diamond\neg p$ &  the same\\
  \hline
  $\Diamond\Box p\imp\Box\Diamond q$ &  weak fairness: `eventually always
  p (eg enabled) only if infinitely often q (eg executed)'\\
  \hline
  $\Box\Diamond p\imp\Box\Diamond q$ &  strong fairness: `infinitely
  often p (eg enabled) only if infinitely often q (eg executed)'\\
  \hline
\end{tabular}
\end{center}

\medskip\noindent Show that $\neg (\neg p \until q)$ means: whenever
in the future $q$ holds, then $p$ must have happened before $q$.

\medskip\noindent Fairness: Note that $\neg\Diamond\Box p$ is
equivalent to $\Diamond\Box p\imp\bot$, so it is a special case of the
more elaborate $\Diamond\Box p\imp\Box\Diamond q$. A typical example
of the latter could be: Always, if a process keeps waiting to enter and
the door remains open, then the process will (be scheduled to) enter
eventually.\footnote{Think eg of an elevator which opens its door and
  doesn't go away. If the scheduler is weakly fair, the process will
  eventually enter.} \footnote{You might want to show that $\Box(\Box
  p\imp\Diamond q) \biimp \Diamond\Box p\imp\Box\Diamond q$.} 
% checked with spin
This is weaker than $\Box\Diamond p\imp\Box\Diamond q$, an example of
which could be: If a process is waiting to enter and the door will
become open inifinitely many times, then the process will (be
scheduled to) enter eventually. \footnote{Think eg of an elevator
  which opens its door, then may go away again, but keeps coming
  back. If the scheduler is strongly fair, the process will eventully
  enter.} \footnote{You might want to show that $(\Box\Diamond
  p\imp\Box\Diamond q) \biimp \Box(\Box\Diamond p \imp \Diamond q)$ or
  also $(\neg\Diamond\Box p\imp\Box\Diamond q) \biimp
  \Box(\neg\Diamond\Box p \imp \Diamond q)$.}


%\input{sr-logic-ml}%Transition systems, modal logic
\subsection{Transition Systems}

A \emph{transition system} $(X,(R_i)_{i\in I},v)$, or \emph{Kripke
  model}, consists of
\begin{itemize}
\item a set $X$ of 'states', also called the carrier of the model,
\item a collection of relations $(R_i)_{i\in I}\subseteq X\times X$,
\item a valuation $v:X\times\bbP\to\bbtwo$ of atomic propositions $\bbP$.
\end{itemize}

\noindent Read $xR_iy$ as $y$ is an $i$-successor of $x$.

\medskip\noindent Why do we have many relations $R_i$? Think of the elements
$i\in I$ as actions, or as the letters of the input alphabet of an
automaton: then in a given state $x$, for each action $i\in I$, we can
have different successors $y$, ie $y$ such that $xR_i y$.

\medskip\noindent To give semantics to distributed processes, we will only need one relation and then we write simply
$(X,R,v)$. 



%\input{sr-logic4}%Tableaux for LTL
\subsection{Transition System Semantics of LTL, Some Remarks on Spin}
%
Let $M=(X,R,v)$ be a transition system and $x\in X$. We call $x$ the
\emph{initial state} of $M$. For LTL-formulae $\phi$, we define
\[M,x\models\phi \textrm{ \ if \ } \sigma,0\models\phi \textrm{ for
  all sequences $\sigma$ through $M$ starting at $x$.}\]


\bigskip\noindent\textbf{Remark. }  This is the semantics used by the
SPIN model checker: A Promela program defines a transition system $M$
together with an initial state $x$; checking a formula $\phi$ against
a Promela model is the same as asking the question whether
\[M,x\models\phi.\]
In case that $M,x\notmodels\phi$, the model checker will produce a
counter example to $\phi$, that is, a particular sequence $\sigma$
such that \[\sigma,0 \notmodels\phi,\] or, which is the
same, \[\sigma,0 \models\neg\phi,\]

\smallskip\noindent Note that, to check $\phi$ using Spin, one has to
use the negation \texttt{!($\phi$)} as in \texttt{spin -f
  '!($\phi$)'}. Spins tries to find a counterexample to $\phi$ by
finding an example of a sequence satisfying $\neg\phi$.

\bigskip\noindent\textbf{Remark on Interleaving Semantics.} The way
SPIN assigns a transition system to a Promela program is an example of
interleaving semantics: No two independent processes are allowed to
move at the same time.  This assumption sounds
unrealistic, but it doesn't matter.

\bigskip\noindent\textbf{Semantics of $U$ (Spin's until). } Spin knows
the temporal operators from Section~\ref{sec:LTL:def}, but uses a
variation of $\until$ written as $U$. Its semantics is given by
\begin{itemize}
\item $\sigma,n\models p U q$ \ if \ \
  \parbox{15em}{$\sigma,m\models q$ for some $m\ge n$ and\\
    $\sigma,k\models p$ for all $k$ with $n\le k < m$.}
\end{itemize}
$U$ can be expressed using $\until$: $p U q \biimp q \ou (p \et (p
\until q))$ but not vice versa: formulae built from $U$ are stutter
invariant (see below). Accordingly, $\bot U q$ does not express $\next q$ but we
have the laws $\bot U q \biimp q$ and $q\imp(p U q)$.

\medskip\noindent $\until$ can be expressed as $(p\until q) \biimp
\next(p U q)$.\footnote{In Spin-LTL one writes \texttt{X} for
  $\next$.}

\bigskip\noindent\textbf{Stutter invariance } An LTL-formula $\phi$ is
said to be stutter-invariant if $(v_n)_{n_\bbN}\models\phi$ implies
that $(v'_n)_{n\in\bbN}\models\phi$ for all stuttervariants
$(v'_n)_{n\in\bbN}$ of $(v_n)_{n\in\bbN}$, where $(v'_n)_{n\in\bbN}$ is
called a \emph{stuttervariant} of $(v_n)_{n\in\bbN}$ if there is a
surjective function $f:\bbN\to\bbN$ such that $f(0)=0$ and either
$f(n+1)=f(n)$ or $f(n+1)=f(n)$ and $v'_n=v_{f(n)}$.


\subsection{Semantic Tableaux for LTL}

\subsubsection*{Motivation and Explanation}

LTL-tableaux are an extension of propositional tableau. Although
technically more complicated, the basic ideas are not
difficult. First,  we need some preliminaries.

\medskip\noindent Recall that, in order to keep the number of rules
small, we used certain laws to transform formulae to a form making the
rules applicable. These laws are summarised in
Table~\ref{table:prop-laws}.  Remember that we apply them from left to
right in a tableau.

\begin{table}
\fbox{\parbox{\textwidth}{
\begin{align*}
(\phi\biimp\psi) & \biimp  (\phi\imp \psi)\et(\psi\imp \phi)\\
\neg(\phi\ou\psi)& \biimp \neg\phi\et\neg\psi\\
\neg(\phi\et\psi)& \biimp \neg\phi\ou\neg\psi\\
\phi\imp\psi &\biimp \neg\phi\ou\psi\\
\neg(\phi\imp\psi)&\biimp \phi\et\neg\psi
\end{align*}
}}
\caption{Propositional laws}\label{table:prop-laws}
\end{table}

\medskip\noindent To deal with the new temporal operators, we add the
laws of Table~\ref{table:ltl-laws}. (Exercise: show that these laws
are valid.) They are again to be applied from left to right. Their
effect is that in the leaves of a propositional tableau, there are
only the following kind of formulae: atomic propositions, negations of
atomic propositions, formulae of the kind $\next\phi$.\footnote{We may
  want to add, for the Spin-version of until,
\begin{align*}
  \phi U\psi & \biimp \psi \ou (\phi\et\next(\phi U\psi)))\\
  \neg(\phi U\psi) & \biimp (\neg\psi \et (\neg\phi\ou
  \next\neg(\phi U\psi)))
\end{align*}
}

%
\begin{table}
  \fbox{\parbox{\textwidth}{
      \begin{align*}
        \neg\next\phi & \biimp \next\neg\phi \\
        \neg\Diamond\phi & \biimp \Box\neg\phi \\
        \neg\Box\phi & \biimp \Diamond\neg\phi\\
% \end{align*}
% and
% \begin{align*}
        \Diamond\phi & \biimp \phi\ou\next\Diamond\phi \\
        \Box\phi & \biimp \phi\et\next\Box\phi\\
        \phi\until\psi & \biimp \next(\psi \ou (\phi\et(\phi\until\psi)))\\
        \neg(\phi\until\psi) & \biimp \next(\neg\psi \et(\neg\phi\ou
        \neg(\phi\until\psi)))
\end{align*}
}}
\caption{Temporal laws}\label{table:ltl-laws}
\end{table}


\paragraph{How do we build an LTL-tableau? }
%
Start building a propositional tableau applying the laws from
Tables~\ref{table:prop-laws} and \ref{table:ltl-laws}.  Now, all the
leaves of this tableau contain only atomic propositions or negations
of atomic propositions or formulae whose outermost connective is
$\next$.

\medskip\noindent These nodes are leaves in a propositional tableaux.
No further propositional reasoning is possible. The leaves correspond
to the states of LTL-models.

\medskip\noindent How to make a transition from one state to the next
will be described now. We first need two definitions.

\medskip\noindent\textbf{Definition. } Let us agree to call a node
labelled with a set of formulas $\Phi$ a
\textbf{state},\footnote{X-node in \cite{benari:logic}} if $\Phi$
contains only atomic propositions or negations of atomic propositions
or formulae whose outermost connective is $\next$; moreover, we assume
that there are no contradictions among the (negated) atomic
propositions.

\medskip\noindent\textbf{Definition. } For a state labelled $\Phi$
define $\Phi'=\{\phi \mid \next\phi\in\Phi\}$.

\medskip\noindent In other words, $\Phi'$ erases the outermost $\next$
operator from formulas in $\Phi$.

\medskip\noindent We now come to the rule for $\next$. The notation
$\Phi'$ has been devised in a way such that, if \emph{now} $\Phi$
holds then at the \emph{next} time-point $\Phi'$ must hold \ldots if
that is not clear, pause to think about it.  We therefore would like
to say that any state $\Phi$ has precisely one child, namely $\Phi'$.
Unfortunately, this does not work, since the tableau for, eg, $\Box p$
would be infinite (easy exercise!).
%
We solve this problem as follows. Given a state labelled $\Phi$, if
there is already a node labelled $\Phi'$, 
then we do not create a child of $\Phi$ and instead ``loop back'' to
the already existing node labelled by $\Phi'$. Otherwise create a child labelled $\Phi'$ and continue as
above.

\medskip\noindent\textbf{Definition. } A tableau is complete if there
is no further rule to apply. A tableau is closed if all branches
contain a contradiction, otherwise it is open.

\medskip\noindent\textbf{Definition. } Given a complete, open tableau,
we extract a graph $(V,E)$ from where the vertices $V$ are the states
of the tableau and there is an edge $(s,t)\in E$ whenever there is
path $(s,s_1,\ldots, s_n,t)$ in the tableau such that the $s_i$ are
non-state nodes. We also define a mapping $F$ from vertices to
formulas. If $(\Phi,\Psi_1,\ldots, \Psi_n,\Phi_2)$ are the set of
formulas labelling $(s,s_1,\ldots, s_n,t)$ in the tableau, then $F(t)$
is defined as $\bigcup\{\Psi_i\mid 1\le i \le
n\}\cup\Phi_2$.

\medskip\noindent\textbf{Extracting a model from a tableau. }  If the
graph of a complete open tableau has a vertex that has no successor,
then the path leading to that vertex is a model of the formula at the
root of the tableau and the formula is therefore satisfiable. If the
graph has a cycle, this cycle is is model if it is selfulfilling,
defined as follows.

\medskip\noindent\textbf{Definition. }  A cycle is
\textbf{self-fulfilling} if
\begin{enumerate}
\item for all vertices $s$ in the cycle and all $\Diamond\phi\in F(s)$
  there is some vertex $t$ in the cycle such that $\phi\in F(t)$
\item for all vertices $s$ in the cycle and all $(\phi\until\psi)\in
  F(s)$ there is some node $t$ in the cycle such that $\psi \in F(t)$
\end{enumerate}
Intuitively, we think of a formula $\Diamond\phi$ as a \emph{promise}
to make $\phi$ true. Now, recall that building a tableau we are trying
to construct a sequence satisfying the formulas in the tableau. In
order to satisfy the promise $\Diamond\phi$, we need that $\phi$ is
true in some node of the sequence. If this happens, we call the
sequence self-fulfilling.

\medskip\noindent\textbf{A summary} of the construction of an
LTL-tableau is given in Table~\ref{table:ltl-tableau}. If the tableau
is not closed, we extract a graph from the tableau. Then the formula
at the root of the tableau is satisfiable if the graph contains a
self-fulfilling cycle.

\begin{table}
\fbox{\parbox{\textwidth}{
\begin{enumerate}
\item Build a complete propositional tableau for $\Psi$ using the laws of
  Tables~\ref{table:prop-laws} and \ref{table:ltl-laws}.
\item We continue as follows (with $\Phi$ ranging over the leaves of
  the propositional tableau just built):

\begin{itemize}
\item If $\Phi$ contains a contradiction, then $\Phi$ has no child and
  the branch is closed.
\item If $\Phi$ does not contain a contradiction:
\begin{itemize}
\item If $\Phi'$ appears on the path from the root to $\Phi$, then no
  new child of $\Phi$ is created but one loops back to $\Phi'$.
\item If $\Phi'$ is empty, then $\Phi$ has no child.
\item Otherwise: $\Phi$ has a child $\Phi'$. (The notation $\Phi'$ was
  defined above.) Go back to 1., continuing
  to build a propositional tableau for $\Psi=\Phi'$.
\end{itemize}
\end{itemize}
\end{enumerate}
}}
\caption{How to build an LTL-tableau with root $\Psi$}\label{table:ltl-tableau}
\end{table}



% \subsubsection{Semantic Tableaux for LTL}\label{sem-tab-LTL}

% The definition of a complete semantic tableau is given in
% Table~\ref{table:complete}. It is closed or open as explained in the
% following.
% %
% \begin{table}
% \fbox{\parbox{\textwidth}{
%   In a complete semantic LTL-tableau, each
%   node is either a state or not. A non-state node satisfies
%   one of the following conditions (which are exactly the same as for
%   propositional tableaux).

% \begin{itemize}
% \item $\Phi$ contains a formula $\phi \ou\psi$ and has exactly
%   two children given by $(\Phi\cup\{\phi\})\setminus\{\phi \ou\psi\}$
%   and $(\Phi\cup\{\psi\})\setminus\{\phi \ou\psi\}$.
    
% \item $\Phi$ contains a formula $\phi \et\psi$ and has exactly
%   one child given by $(\Phi\cup\{\phi,\psi\})\setminus\{\phi
%   \et\psi\}$.
      
% \item $\Phi$ contains a formula $\neg\neg\phi$ and has exactly one
%   child given by $(\Phi\cup\{\phi\})\setminus\{\neg\neg\phi\}$.
% \end{itemize}


% \noindent For state nodes we have:
% \begin{itemize}
% \item State nodes $\Phi$ that contain a contradiction, or
%   have a subsuming ancestor or have empty $\Phi'$ have no child.
%   Otherwise $\Phi$ has one child $\Phi'$.
% \end{itemize}
% }
% }
% \caption{Complete semantic tableau for LTL}\label{table:complete}
% \end{table}

% Note how the first three items of Table~\ref{table:complete}
% correspond to those in
% Tables~\ref{table:tableau-rules}~\ref{table:tableau-rules-short}.  The
% last item of Table~\ref{table:complete} can be written in the notation
% of Table~\ref{table:ltl-rules-short}.

% \begin{table}
% \fbox{\parbox{\textwidth}{
% \[
% \rules{p_1,p_2,\ldots \neg q_1,\neg q_2,\ldots,\next\phi_1,\next\phi_2,\ldots }{\phi_1,\phi_2,\ldots}
% \]
% }}
% \caption{LTL tableau rule for state nodes (``steps in time'')}\label{table:ltl-rules-short}
% \end{table}

% \medskip The way we defined `state', all leaves are
% states.  If a leaf contains a contradiction it is called closed.
% If a leaf does not contain a contradiction and does not have a
% subsuming ancestor it is open. If a leaf does have a subsuming
% ancestor then it is open or closed depending on whether the loop is
% self-fulfilling or not. In other words:

% \medskip\noindent A complete semantic tableau for $\{\neg\phi\}$ is
% \emph{open} if it contains an \emph{open leaf} $\Phi$, that is, a leaf
% $\Phi$ that contains no contradiction and, moreover, if $\Phi$ is in a
% loop, then the loop associated with $\Phi$ is self-fulfilling.


% \medskip\noindent The path from the root to the leaf gives rise to an
% (infinite) sequence satisfying $\{\neg\phi\}$. A tableau is
% \emph{closed} if it is not open. A formula $\phi$ is valid if there is
% some closed semantic tableau which has $\{\neg\phi\}$ as its root.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "sr-logic"
%%% End: 
